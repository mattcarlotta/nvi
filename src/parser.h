#ifndef NVI_PARSER_H
#define NVI_PARSER_H

#include "lexer.h"
#include "log.h"
#include "options.h"
#include <cstddef>
#include <fstream>
#include <map>
#include <string>
#include <string_view>
#include <vector>

namespace nvi {
    typedef std::map<std::string, std::string> env_map_t;

    /**
     * @detail Parses and interpolates lexer tokens into a single object of `"key": "value"` pairs.
     * @param `tokens` initialize parser with tokens generated by the lexer
     * @param `options` initialize parser with the following required option: `files`, followed by optional options:
     * `api`, `debug`, `dir`, `environment`, `project` and `required_envs`.
     * @example Initializing a parser, parsing .env files and checking ENVs
     *
     * nvi::options_t options;
     * options.api = false;
     * options.debug = false;
     * options.dir = "custom/path/to/envs";
     * options.files = {".env", "base.env", ...etc};
     * optons.required_envs = {"KEY1", "KEY2", ...etc};
     * nvi::Lexer lexer(&options);
     * nvi::tokens_t tokens = lexer.parse_files()->get_tokens();
     * nvi::Parser parser(tokens, options);
     * parser.parse_envs();
     */
    class Parser {
        public:
        Parser(tokens_t tokens, options_t &options);
        const env_map_t &get_env_map() const noexcept;
        Parser *parse_tokens() noexcept;

        private:
        void log(const messages_t &code) const noexcept;

        tokens_t _tokens;
        options_t &_options;
        Token _token;
        ValueToken _value_token;
        std::string _key;
        std::string _interp_key;
        std::string _value;
        std::vector<std::string> _undefined_keys;
        env_map_t _env_map;
    };
}; // namespace nvi
#endif
